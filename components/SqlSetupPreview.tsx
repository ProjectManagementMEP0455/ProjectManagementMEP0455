
import React, { useState } from 'react';
import Button from './ui/Button';

// FIX: The SQL script is now stored as a string constant within a valid React component.
const sqlScript = `-- MEP-DASH: SAFE MIGRATION & SETUP SCRIPT V11
-- This script is NON-DESTRUCTIVE to user data. It is designed to be
-- run safely on an existing database to apply updates without wiping
-- profiles, projects, or other critical information. It resolves the
-- issue of needing to delete users from Supabase Auth on every update.
--
-- V11 CHANGES: Fixes a critical bug where Site Engineers could not submit
-- material requests by updating the RLS policy for the 'requests' table
-- to be more explicit about which roles have INSERT permissions. Also
-- improves security of the request UPDATE policy.
--
-- INSTRUCTIONS:
-- 1. If this is your first time setting up, ensure you have created
--    three public Storage buckets in Supabase: 'invoices', 'progress-photos',
--    and 'request-attachments'.
-- 2. Run this entire script in the Supabase SQL Editor. It's safe to run
--    even if you have existing users and projects.
-- 3. The first user to sign up will become an Admin. After that, public
--    sign-up is disabled, and new users must be created from the Admin Panel.
----------------------------------------------------------------

-- PART 0: CLEANUP (Safe cleanup of functions/triggers that will be replaced)
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
-- NOTE: We no longer drop tables to preserve user data.

-- PART 1: CREATE CUSTOM TYPES (if they don't exist)
DO $$ BEGIN CREATE TYPE public.user_role AS ENUM ('Admin', 'Project Director', 'Project Manager', 'Assistant Project Manager', 'Engineer / Supervisor', 'Site Engineer / Technician', 'Office Accountant'); EXCEPTION WHEN duplicate_object THEN null; END $$;
DO $$ BEGIN CREATE TYPE public.project_status AS ENUM ('Active', 'Planning', 'Completed', 'On Hold'); EXCEPTION WHEN duplicate_object THEN null; END $$;
DO $$ BEGIN CREATE TYPE public.task_status AS ENUM ('To Do', 'In Progress', 'Done'); EXCEPTION WHEN duplicate_object THEN null; END $$;
DO $$ BEGIN CREATE TYPE public.request_status AS ENUM ('Pending', 'Approved', 'Rejected', 'Processed'); EXCEPTION WHEN duplicate_object THEN null; END $$;

-- PART 2: CREATE TABLES (if they don't exist)
-- This ensures that existing data is NOT deleted.
CREATE TABLE IF NOT EXISTS public.profiles (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users ON DELETE CASCADE,
    full_name text,
    avatar_url text,
    role public.user_role
);
CREATE TABLE IF NOT EXISTS public.materials_master (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL,
    unit text,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);
CREATE TABLE IF NOT EXISTS public.projects (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    description text,
    start_date date,
    end_date date,
    budget numeric DEFAULT 0,
    spent numeric DEFAULT 0,
    status public.project_status DEFAULT 'Planning'::public.project_status,
    created_by uuid REFERENCES public.profiles ON DELETE SET NULL
);
CREATE TABLE IF NOT EXISTS public.project_team_members (
    project_id bigint NOT NULL REFERENCES public.projects ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES public.profiles ON DELETE CASCADE,
    PRIMARY KEY (project_id, user_id)
);
CREATE TABLE IF NOT EXISTS public.tasks (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    description text,
    status public.task_status DEFAULT 'To Do'::public.task_status,
    start_date date,
    due_date date,
    assignee_id uuid REFERENCES public.profiles ON DELETE SET NULL,
    project_id bigint NOT NULL REFERENCES public.projects ON DELETE CASCADE,
    percent_complete integer DEFAULT 0 CHECK (percent_complete >= 0 AND percent_complete <= 100),
    budgeted_cost numeric DEFAULT 0,
    spent_cost numeric DEFAULT 0
);
CREATE TABLE IF NOT EXISTS public.milestones (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    name text NOT NULL,
    due_date date NOT NULL,
    project_id bigint NOT NULL REFERENCES public.projects ON DELETE CASCADE,
    completed boolean DEFAULT false NOT NULL
);
CREATE TABLE IF NOT EXISTS public.expenses (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    task_id bigint NOT NULL REFERENCES public.tasks ON DELETE CASCADE,
    project_id bigint NOT NULL REFERENCES public.projects ON DELETE CASCADE,
    description text NOT NULL,
    amount numeric NOT NULL,
    created_by uuid NOT NULL REFERENCES public.profiles ON DELETE SET NULL,
    document_url text,
    expense_date date NOT NULL
);
CREATE TABLE IF NOT EXISTS public.requests (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    project_id bigint NOT NULL REFERENCES public.projects ON DELETE CASCADE,
    requested_by uuid NOT NULL REFERENCES public.profiles ON DELETE SET NULL,
    description text NOT NULL,
    estimated_cost numeric NOT NULL,
    status public.request_status DEFAULT 'Pending'::public.request_status,
    reviewed_by uuid REFERENCES public.profiles ON DELETE SET NULL,
    review_notes text,
    linked_expense_id bigint REFERENCES public.expenses ON DELETE SET NULL,
    document_url text
);
-- Add columns for material request details if they don't exist
ALTER TABLE public.requests ADD COLUMN IF NOT EXISTS quantity numeric;
ALTER TABLE public.requests ADD COLUMN IF NOT EXISTS unit text;

CREATE TABLE IF NOT EXISTS public.progress_photos (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    project_id bigint NOT NULL REFERENCES public.projects ON DELETE CASCADE,
    uploaded_by uuid NOT NULL REFERENCES public.profiles ON DELETE SET NULL,
    photo_url text NOT NULL,
    caption text,
    photo_date date NOT NULL
);
CREATE TABLE IF NOT EXISTS public.app_settings (
    key text PRIMARY KEY,
    value text
);


-- PART 3: TRIGGERS & AUTOMATION (Idempotent updates)
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
  user_count integer;
BEGIN
  -- Check if a user with this ID already has a profile.
  -- This prevents errors if the trigger is run multiple times for the same user.
  IF EXISTS (SELECT 1 FROM public.profiles WHERE id = NEW.id) THEN
    RETURN NEW;
  END IF;

  SELECT count(*) INTO user_count FROM public.profiles;
  IF user_count = 0 THEN
    INSERT INTO public.profiles (id, full_name, avatar_url, role)
    VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name', NEW.raw_user_meta_data->>'avatar_url', 'Admin');
  ELSE
    IF (NEW.raw_user_meta_data->>'role') IS NULL THEN
      RAISE EXCEPTION 'Public sign-up is disabled. Please ask an administrator to create your account.';
    END IF;
    INSERT INTO public.profiles (id, full_name, avatar_url, role)
    VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name', NEW.raw_user_meta_data->>'avatar_url', (NEW.raw_user_meta_data->>'role')::public.user_role);
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Recreate trigger to ensure it's up-to-date
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


CREATE OR REPLACE FUNCTION public.update_task_spent_cost()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE public.tasks
    SET spent_cost = (
        SELECT COALESCE(SUM(amount), 0)
        FROM public.expenses
        WHERE task_id = COALESCE(NEW.task_id, OLD.task_id)
    )
    WHERE id = COALESCE(NEW.task_id, OLD.task_id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS expenses_update_task_spent_trigger ON public.expenses;
CREATE TRIGGER expenses_update_task_spent_trigger
AFTER INSERT OR UPDATE OF amount OR DELETE ON public.expenses
FOR EACH ROW EXECUTE FUNCTION public.update_task_spent_cost();

CREATE OR REPLACE FUNCTION public.update_project_spent()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE public.projects
    SET spent = (
      SELECT COALESCE(SUM(spent_cost), 0)
      FROM public.tasks
      WHERE project_id = COALESCE(NEW.project_id, OLD.project_id)
    )
    WHERE id = COALESCE(NEW.project_id, OLD.project_id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS tasks_update_project_spent_trigger ON public.tasks;
CREATE TRIGGER tasks_update_project_spent_trigger
AFTER INSERT OR UPDATE OF spent_cost OR DELETE ON public.tasks
FOR EACH ROW EXECUTE FUNCTION public.update_project_spent();

CREATE OR REPLACE FUNCTION public.update_project_budget()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE public.projects
    SET budget = (
      SELECT COALESCE(SUM(budgeted_cost), 0)
      FROM public.tasks
      WHERE project_id = COALESCE(NEW.project_id, OLD.project_id)
    )
    WHERE id = COALESCE(NEW.project_id, OLD.project_id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS tasks_update_project_budget_trigger ON public.tasks;
CREATE TRIGGER tasks_update_project_budget_trigger
AFTER INSERT OR UPDATE OF budgeted_cost OR DELETE ON public.tasks
FOR EACH ROW EXECUTE FUNCTION public.update_project_budget();


-- PART 4: RLS (Row Level Security) & PERMISSIONS
GRANT USAGE ON SCHEMA public TO anon, authenticated;

CREATE OR REPLACE FUNCTION public.is_admin(u_id uuid)
RETURNS boolean LANGUAGE sql SECURITY DEFINER SET search_path = public AS $$
  SELECT EXISTS (SELECT 1 FROM profiles WHERE id = u_id AND role = 'Admin'::public.user_role);
$$;

CREATE OR REPLACE FUNCTION public.is_member_of_project(p_id bigint, u_id uuid)
RETURNS boolean LANGUAGE sql SECURITY DEFINER SET search_path = public AS $$
  SELECT EXISTS (SELECT 1 FROM project_team_members WHERE project_id = p_id AND user_id = u_id);
$$;

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.projects ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.project_team_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tasks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.milestones ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.expenses ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.progress_photos ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.materials_master ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.app_settings ENABLE ROW LEVEL SECURITY;

GRANT SELECT ON TABLE public.profiles TO anon;
GRANT SELECT ON TABLE public.app_settings TO authenticated;

DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);
DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
DROP POLICY IF EXISTS "Users can update their own profile." ON public.profiles;
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);
DROP POLICY IF EXISTS "Admins can update any profile." ON public.profiles;
CREATE POLICY "Admins can update any profile." ON public.profiles FOR UPDATE USING (public.is_admin(auth.uid()));

DROP POLICY IF EXISTS "Admins or team members can view projects." ON public.projects;
CREATE POLICY "Admins or team members can view projects." ON public.projects FOR SELECT USING (public.is_member_of_project(id, auth.uid()) OR public.is_admin(auth.uid()));
DROP POLICY IF EXISTS "Admins/Directors/Managers can create projects." ON public.projects;
CREATE POLICY "Admins/Directors/Managers can create projects." ON public.projects FOR INSERT WITH CHECK (((SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('Admin'::public.user_role, 'Project Director'::public.user_role, 'Project Manager'::public.user_role)));
DROP POLICY IF EXISTS "Admins or team Directors/Managers can update projects." ON public.projects;
CREATE POLICY "Admins or team Directors/Managers can update projects." ON public.projects FOR UPDATE USING ((public.is_member_of_project(id, auth.uid()) AND (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('Project Director'::public.user_role, 'Project Manager'::public.user_role)) OR public.is_admin(auth.uid()));

DROP POLICY IF EXISTS "Team members can view their own project members." ON public.project_team_members;
CREATE POLICY "Team members can view their own project members." ON public.project_team_members FOR SELECT USING (public.is_member_of_project(project_id, auth.uid()));
DROP POLICY IF EXISTS "Admins or team Directors/Managers can manage team." ON public.project_team_members;
CREATE POLICY "Admins or team Directors/Managers can manage team." ON public.project_team_members FOR ALL USING (((public.is_member_of_project(project_id, auth.uid()) AND (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('Project Director'::public.user_role, 'Project Manager'::public.user_role))) OR public.is_admin(auth.uid()));

DROP POLICY IF EXISTS "Team members can view tasks." ON public.tasks;
CREATE POLICY "Team members can view tasks." ON public.tasks FOR SELECT USING (public.is_member_of_project(project_id, auth.uid()));
DROP POLICY IF EXISTS "Team members (except technicians) can manage tasks." ON public.tasks;
CREATE POLICY "Team members (except technicians) can manage tasks." ON public.tasks FOR ALL USING ((public.is_member_of_project(project_id, auth.uid()) AND (SELECT role FROM public.profiles WHERE id = auth.uid()) <> 'Site Engineer / Technician'::public.user_role) OR public.is_admin(auth.uid()));

DROP POLICY IF EXISTS "Team members can view milestones." ON public.milestones;
CREATE POLICY "Team members can view milestones." ON public.milestones FOR SELECT USING (public.is_member_of_project(project_id, auth.uid()));
DROP POLICY IF EXISTS "Admins or team Managers can manage milestones." ON public.milestones;
CREATE POLICY "Admins or team Managers can manage milestones." ON public.milestones FOR ALL USING (((public.is_member_of_project(project_id, auth.uid()) AND (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('Project Director'::public.user_role, 'Project Manager'::public.user_role, 'Assistant Project Manager'::public.user_role))) OR public.is_admin(auth.uid()));

DROP POLICY IF EXISTS "Team members can view expenses." ON public.expenses;
CREATE POLICY "Team members can view expenses." ON public.expenses FOR SELECT USING (public.is_member_of_project(project_id, auth.uid()));
DROP POLICY IF EXISTS "Accountants or Admins can manage expenses." ON public.expenses;
CREATE POLICY "Accountants or Admins can manage expenses." ON public.expenses FOR ALL USING (((SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('Office Accountant'::public.user_role, 'Admin'::public.user_role)));

-- ** REQUESTS POLICIES: UPDATED FOR V11 **
DROP POLICY IF EXISTS "Team members can view requests." ON public.requests;
CREATE POLICY "Team members can view requests." ON public.requests FOR SELECT USING (public.is_member_of_project(project_id, auth.uid()));

DROP POLICY IF EXISTS "Authorized team members can create requests." ON public.requests;
CREATE POLICY "Authorized team members can create requests." ON public.requests FOR INSERT WITH CHECK (
    public.is_member_of_project(project_id, auth.uid()) AND
    (SELECT role FROM public.profiles WHERE id = auth.uid()) IN (
        'Admin'::public.user_role,
        'Project Director'::public.user_role,
        'Project Manager'::public.user_role,
        'Assistant Project Manager'::public.user_role,
        'Engineer / Supervisor'::public.user_role,
        'Site Engineer / Technician'::public.user_role
    )
);

DROP POLICY IF EXISTS "Accountants or Admins can manage requests." ON public.requests;
CREATE POLICY "Accountants or Admins can manage requests." ON public.requests FOR UPDATE USING (
    public.is_member_of_project(project_id, auth.uid()) AND
    ((SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('Office Accountant'::public.user_role, 'Admin'::public.user_role))
);


DROP POLICY IF EXISTS "Team members can view photos." ON public.progress_photos;
CREATE POLICY "Team members can view photos." ON public.progress_photos FOR SELECT USING (public.is_member_of_project(project_id, auth.uid()));
DROP POLICY IF EXISTS "Team members can upload photos." ON public.progress_photos;
CREATE POLICY "Team members can upload photos." ON public.progress_photos FOR INSERT WITH CHECK (public.is_member_of_project(project_id, auth.uid()));
DROP POLICY IF EXISTS "Admins or uploader can delete photos." ON public.progress_photos;
CREATE POLICY "Admins or uploader can delete photos." ON public.progress_photos FOR DELETE USING (public.is_admin(auth.uid()) OR uploaded_by = auth.uid());

DROP POLICY IF EXISTS "Admins can manage master materials list." ON public.materials_master;
CREATE POLICY "Admins can manage master materials list." ON public.materials_master FOR ALL USING (public.is_admin(auth.uid()));
DROP POLICY IF EXISTS "Authenticated users can view materials." ON public.materials_master;
CREATE POLICY "Authenticated users can view materials." ON public.materials_master FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Authenticated users can read settings." ON public.app_settings;
CREATE POLICY "Authenticated users can read settings." ON public.app_settings FOR SELECT USING (auth.role() = 'authenticated');
DROP POLICY IF EXISTS "Admins can manage settings." ON public.app_settings;
CREATE POLICY "Admins can manage settings." ON public.app_settings FOR ALL USING (public.is_admin(auth.uid()));


-- PART 5: FINALIZATION & DEFAULT DATA
INSERT INTO public.app_settings (key, value) VALUES ('project_completion_method', 'BASED_ON_TASKS') ON CONFLICT (key) DO NOTHING;
SELECT 'SUCCESS: MEP-Dash database has been set up/updated without deleting user data.' as status;
`;

const SqlSetupPreview: React.FC = () => {
    const [copyStatus, setCopyStatus] = useState('Copy to Clipboard');

    const handleCopy = () => {
        navigator.clipboard.writeText(sqlScript).then(() => {
            setCopyStatus('Copied!');
            setTimeout(() => setCopyStatus('Copy to Clipboard'), 2000);
        }, () => {
            setCopyStatus('Failed to copy!');
            setTimeout(() => setCopyStatus('Copy to Clipboard'), 2000);
        });
    };

    return (
        <div className="space-y-4">
            <p className="text-sm text-muted-foreground">
                Run the following SQL script in your Supabase project's SQL Editor to create the necessary tables, roles, and policies. 
                This script is safe to run multiple times.
            </p>
            <div className="relative">
                <pre className="bg-background/80 border border-border rounded-md p-4 max-h-60 overflow-auto text-xs">
                    <code>{sqlScript}</code>
                </pre>
                <div className="absolute top-2 right-2">
                    <Button onClick={handleCopy} variant="secondary" size="sm">
                        {copyStatus}
                    </Button>
                </div>
            </div>
        </div>
    );
};

export default SqlSetupPreview;
